{"ts":1372863278071,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * impress.js\n *\n * impress.js is a presentation tool based on the power of CSS3 transforms and transitions\n * in modern browsers and inspired by the idea behind prezi.com.\n *\n *\n * Copyright 2011-2012 Bartek Szopka (@bartaz)\n *\n * Released under the MIT and GPL Licenses.\n *\n * ------------------------------------------------\n *  author:  Bartek Szopka\n *  version: 0.5.3\n *  url:     http://bartaz.github.com/impress.js/\n *  source:  http://github.com/bartaz/impress.js/\n */\n\n/*jshint bitwise:true, curly:true, eqeqeq:true, forin:true, latedef:true, newcap:true,\n         noarg:true, noempty:true, undef:true, strict:true, browser:true */\n\n// You are one of those who like to know how thing work inside?\n// Let me show you the cogs that make impress.js run...\n(function ( document, window ) {\n    'use strict';\n    \n    // HELPER FUNCTIONS\n    \n    // `pfx` is a function that takes a standard CSS property name as a parameter\n    // and returns it's prefixed version valid for current browser it runs in.\n    // The code is heavily inspired by Modernizr http://www.modernizr.com/\n    var pfx = (function () {\n        \n        var style = document.createElement('dummy').style,\n            prefixes = 'Webkit Moz O ms Khtml'.split(' '),\n            memory = {};\n        \n        return function ( prop ) {\n            if ( typeof memory[ prop ] === \"undefined\" ) {\n                \n                var ucProp  = prop.charAt(0).toUpperCase() + prop.substr(1),\n                    props   = (prop + ' ' + prefixes.join(ucProp + ' ') + ucProp).split(' ');\n                \n                memory[ prop ] = null;\n                for ( var i in props ) {\n                    if ( style[ props[i] ] !== undefined ) {\n                        memory[ prop ] = props[i];\n                        break;\n                    }\n                }\n            \n            }\n            \n            return memory[ prop ];\n        };\n    \n    })();\n    \n    // `arraify` takes an array-like object and turns it into real Array\n    // to make all the Array.prototype goodness available.\n    var arrayify = function ( a ) {\n        return [].slice.call( a );\n    };\n    \n    // `css` function applies the styles given in `props` object to the element\n    // given as `el`. It runs all property names through `pfx` function to make\n    // sure proper prefixed version of the property is used.\n    var css = function ( el, props ) {\n        var key, pkey;\n        for ( key in props ) {\n            if ( props.hasOwnProperty(key) ) {\n                pkey = pfx(key);\n                if ( pkey !== null ) {\n                    el.style[pkey] = props[key];\n                }\n            }\n        }\n        return el;\n    };\n    \n    // `toNumber` takes a value given as `numeric` parameter and tries to turn\n    // it into a number. If it is not possible it returns 0 (or other value\n    // given as `fallback`).\n    var toNumber = function (numeric, fallback) {\n        return isNaN(numeric) ? (fallback || 0) : Number(numeric);\n    };\n    \n    // `byId` returns element with given `id` - you probably have guessed that ;)\n    var byId = function ( id ) {\n        return document.getElementById(id);\n    };\n    \n    // `$` returns first element for given CSS `selector` in the `context` of\n    // the given element or whole document.\n    var $ = function ( selector, context ) {\n        context = context || document;\n        return context.querySelector(selector);\n    };\n    \n    // `$$` return an array of elements for given CSS `selector` in the `context` of\n    // the given element or whole document.\n    var $$ = function ( selector, context ) {\n        context = context || document;\n        return arrayify( context.querySelectorAll(selector) );\n    };\n    \n    // `triggerEvent` builds a custom DOM event with given `eventName` and `detail` data\n    // and triggers it on element given as `el`.\n    var triggerEvent = function (el, eventName, detail) {\n        var event = document.createEvent(\"CustomEvent\");\n        event.initCustomEvent(eventName, true, true, detail);\n        el.dispatchEvent(event);\n    };\n    \n    // `translate` builds a translate transform string for given data.\n    var translate = function ( t ) {\n        return \" translate3d(\" + t.x + \"px,\" + t.y + \"px,\" + t.z + \"px) \";\n    };\n    \n    // `rotate` builds a rotate transform string for given data.\n    // By default the rotations are in X Y Z order that can be reverted by passing `true`\n    // as second parameter.\n    var rotate = function ( r, revert ) {\n        var rX = \" rotateX(\" + r.x + \"deg) \",\n            rY = \" rotateY(\" + r.y + \"deg) \",\n            rZ = \" rotateZ(\" + r.z + \"deg) \";\n        \n        return revert ? rZ+rY+rX : rX+rY+rZ;\n    };\n    \n    // `scale` builds a scale transform string for given data.\n    var scale = function ( s ) {\n        return \" scale(\" + s + \") \";\n    };\n    \n    // `perspective` builds a perspective transform string for given data.\n    var perspective = function ( p ) {\n        return \" perspective(\" + p + \"px) \";\n    };\n    \n    // `getElementFromHash` returns an element located by id from hash part of\n    // window location.\n    var getElementFromHash = function () {\n        // get id from url # by removing `#` or `#/` from the beginning,\n        // so both \"fallback\" `#slide-id` and \"enhanced\" `#/slide-id` will work\n        return byId( window.location.hash.replace(/^#\\/?/,\"\") );\n    };\n    \n    // `computeWindowScale` counts the scale factor between window size and size\n    // defined for the presentation in the config.\n    var computeWindowScale = function ( config ) {\n        var hScale = window.innerHeight / config.height,\n            wScale = window.innerWidth / config.width,\n            scale = hScale > wScale ? wScale : hScale;\n        \n        if (config.maxScale && scale > config.maxScale) {\n            scale = config.maxScale;\n        }\n        \n        if (config.minScale && scale < config.minScale) {\n            scale = config.minScale;\n        }\n        \n        return scale;\n    };\n    \n    // CHECK SUPPORT\n    var body = document.body;\n    \n    var ua = navigator.userAgent.toLowerCase();\n    var impressSupported = \n                          // browser should support CSS 3D transtorms \n                           ( pfx(\"perspective\") !== null ) &&\n                           \n                          // and `classList` and `dataset` APIs\n                           ( body.classList ) &&\n                           ( body.dataset ) &&\n                           \n                          // but some mobile devices need to be blacklisted,\n                          // because their CSS 3D support or hardware is not\n                          // good enough to run impress.js properly, sorry...\n                           ( ua.search(/(iphone)|(ipod)|(android)/) === -1 );\n    \n    if (!impressSupported) {\n        // we can't be sure that `classList` is supported\n        body.className += \" impress-not-supported \";\n    } else {\n        body.classList.remove(\"impress-not-supported\");\n        body.classList.add(\"impress-supported\");\n    }\n    \n    // GLOBALS AND DEFAULTS\n    \n    // This is were the root elements of all impress.js instances will be kept.\n    // Yes, this means you can have more than one instance on a page, but I'm not\n    // sure if it makes any sense in practice ;)\n    var roots = {};\n    \n    // some default config values.\n    var defaults = {\n        width: 1024,\n        height: 768,\n        maxScale: 1,\n        minScale: 0,\n        \n        perspective: 1000,\n        \n        transitionDuration: 1000\n    };\n    \n    // it's just an empty function ... and a useless comment.\n    var empty = function () { return false; };\n    \n    // IMPRESS.JS API\n    \n    // And that's where interesting things will start to happen.\n    // It's the core `impress` function that returns the impress.js API\n    // for a presentation based on the element with given id ('impress'\n    // by default).\n    var impress = window.impress = function ( rootId ) {\n        \n        // If impress.js is not supported by the browser return a dummy API\n        // it may not be a perfect solution but we return early and avoid\n        // running code that may use features not implemented in the browser.\n        if (!impressSupported) {\n            return {\n                init: empty,\n                goto: empty,\n                prev: empty,\n                next: empty\n            };\n        }\n        \n        rootId = rootId || \"impress\";\n        \n        // if given root is already initialized just return the API\n        if (roots[\"impress-root-\" + rootId]) {\n            return roots[\"impress-root-\" + rootId];\n        }\n        \n        // data of all presentation steps\n        var stepsData = {};\n        \n        // element of currently active step\n        var activeStep = null;\n        \n        // current state (position, rotation and scale) of the presentation\n        var currentState = null;\n        \n        // array of step elements\n        var steps = null;\n        \n        // configuration options\n        var config = null;\n        \n        // scale factor of the browser window\n        var windowScale = null;        \n        \n        // root presentation elements\n        var root = byId( rootId );\n        var canvas = document.createElement(\"div\");\n        \n        var initialized = false;\n        \n        // STEP EVENTS\n        //\n        // There are currently two step events triggered by impress.js\n        // `impress:stepenter` is triggered when the step is shown on the \n        // screen (the transition from the previous one is finished) and\n        // `impress:stepleave` is triggered when the step is left (the\n        // transition to next step just starts).\n        \n        // reference to last entered step\n        var lastEntered = null;\n        \n        // `onStepEnter` is called whenever the step element is entered\n        // but the event is triggered only if the step is different than\n        // last entered step.\n        var onStepEnter = function (step) {\n            if (lastEntered !== step) {\n                triggerEvent(step, \"impress:stepenter\");\n                lastEntered = step;\n            }\n        };\n        \n        // `onStepLeave` is called whenever the step element is left\n        // but the event is triggered only if the step is the same as\n        // last entered step.\n        var onStepLeave = function (step) {\n            if (lastEntered === step) {\n                triggerEvent(step, \"impress:stepleave\");\n                lastEntered = null;\n            }\n        };\n        \n        // `initStep` initializes given step element by reading data from its\n        // data attributes and setting correct styles.\n        var initStep = function ( el, idx ) {\n            var data = el.dataset,\n                step = {\n                    translate: {\n                        x: toNumber(data.x),\n                        y: toNumber(data.y),\n                        z: toNumber(data.z)\n                    },\n                    rotate: {\n                        x: toNumber(data.rotateX),\n                        y: toNumber(data.rotateY),\n                        z: toNumber(data.rotateZ || data.rotate)\n                    },\n                    scale: toNumber(data.scale, 1),\n                    el: el\n                };\n            \n            if ( !el.id ) {\n                el.id = \"step-\" + (idx + 1);\n            }\n            \n            stepsData[\"impress-\" + el.id] = step;\n            \n            css(el, {\n                position: \"absolute\",\n                transform: \"translate(-50%,-50%)\" +\n                           translate(step.translate) +\n                           rotate(step.rotate) +\n                           scale(step.scale),\n                transformStyle: \"preserve-3d\"\n            });\n        };\n        \n        // `init` API function that initializes (and runs) the presentation.\n        var init = function () {\n            if (initialized) { return; }\n            \n            // First we set up the viewport for mobile devices.\n            // For some reason iPad goes nuts when it is not done properly.\n            var meta = $(\"meta[name='viewport']\") || document.createElement(\"meta\");\n            meta.content = \"width=device-width, minimum-scale=1, maximum-scale=1, user-scalable=no\";\n            if (meta.parentNode !== document.head) {\n                meta.name = 'viewport';\n                document.head.appendChild(meta);\n            }\n            \n            // initialize configuration object\n            var rootData = root.dataset;\n            config = {\n                width: toNumber( rootData.width, defaults.width ),\n                height: toNumber( rootData.height, defaults.height ),\n                maxScale: toNumber( rootData.maxScale, defaults.maxScale ),\n                minScale: toNumber( rootData.minScale, defaults.minScale ),                \n                perspective: toNumber( rootData.perspective, defaults.perspective ),\n                transitionDuration: toNumber( rootData.transitionDuration, defaults.transitionDuration )\n            };\n            \n            windowScale = computeWindowScale( config );\n            \n            // wrap steps with \"canvas\" element\n            arrayify( root.childNodes ).forEach(function ( el ) {\n                canvas.appendChild( el );\n            });\n            root.appendChild(canvas);\n            \n            // set initial styles\n            document.documentElement.style.height = \"100%\";\n            \n            css(body, {\n                height: \"100%\",\n                overflow: \"hidden\"\n            });\n            \n            var rootStyles = {\n                position: \"absolute\",\n                transformOrigin: \"top left\",\n                transition: \"all 0s ease-in-out\",\n                transformStyle: \"preserve-3d\"\n            };\n            \n            css(root, rootStyles);\n            css(root, {\n                top: \"50%\",\n                left: \"50%\",\n                transform: perspective( config.perspective/windowScale ) + scale( windowScale )\n            });\n            css(canvas, rootStyles);\n            \n            body.classList.remove(\"impress-disabled\");\n            body.classList.add(\"impress-enabled\");\n            \n            // get and init steps\n            steps = $$(\".step\", root);\n            steps.forEach( initStep );\n            \n            // set a default initial state of the canvas\n            currentState = {\n                translate: { x: 0, y: 0, z: 0 },\n                rotate:    { x: 0, y: 0, z: 0 },\n                scale:     1\n            };\n            \n            initialized = true;\n            \n            triggerEvent(root, \"impress:init\", { api: roots[ \"impress-root-\" + rootId ] });\n        };\n        \n        // `getStep` is a helper function that returns a step element defined by parameter.\n        // If a number is given, step with index given by the number is returned, if a string\n        // is given step element with such id is returned, if DOM element is given it is returned\n        // if it is a correct step element.\n        var getStep = function ( step ) {\n            if (typeof step === \"number\") {\n                step = step < 0 ? steps[ steps.length + step] : steps[ step ];\n            } else if (typeof step === \"string\") {\n                step = byId(step);\n            }\n            return (step && step.id && stepsData[\"impress-\" + step.id]) ? step : null;\n        };\n        \n        // used to reset timeout for `impress:stepenter` event\n        var stepEnterTimeout = null;\n        \n        // `goto` API function that moves to step given with `el` parameter (by index, id or element),\n        // with a transition `duration` optionally given as second parameter.\n        var goto = function ( el, duration ) {\n            \n            if ( !initialized || !(el = getStep(el)) ) {\n                // presentation not initialized or given element is not a step\n                return false;\n            }\n            \n            // Sometimes it's possible to trigger focus on first link with some keyboard action.\n            // Browser in such a case tries to scroll the page to make this element visible\n            // (even that body overflow is set to hidden) and it breaks our careful positioning.\n            //\n            // So, as a lousy (and lazy) workaround we will make the page scroll back to the top\n            // whenever slide is selected\n            //\n            // If you are reading this and know any better way to handle it, I'll be glad to hear about it!\n            window.scrollTo(0, 0);\n            \n            var step = stepsData[\"impress-\" + el.id];\n            \n            if ( activeStep ) {\n                activeStep.classList.remove(\"active\");\n                body.classList.remove(\"impress-on-\" + activeStep.id);\n            }\n            el.classList.add(\"active\");\n            \n            body.classList.add(\"impress-on-\" + el.id);\n            \n            // compute target state of the canvas based on given step\n            var target = {\n                rotate: {\n                    x: -step.rotate.x,\n                    y: -step.rotate.y,\n                    z: -step.rotate.z\n                },\n                translate: {\n                    x: -step.translate.x,\n                    y: -step.translate.y,\n                    z: -step.translate.z\n                },\n                scale: 1 / step.scale\n            };\n            \n            // Check if the transition is zooming in or not.\n            //\n            // This information is used to alter the transition style:\n            // when we are zooming in - we start with move and rotate transition\n            // and the scaling is delayed, but when we are zooming out we start\n            // with scaling down and move and rotation are delayed.\n            var zoomin = target.scale >= currentState.scale;\n            \n            duration = toNumber(duration, config.transitionDuration);\n            var delay = (duration / 2);\n            \n            // if the same step is re-selected, force computing window scaling,\n            // because it is likely to be caused by window resize\n            if (el === activeStep) {\n                windowScale = computeWindowScale(config);\n            }\n            \n            var targetScale = target.scale * windowScale;\n            \n            // trigger leave of currently active element (if it's not the same step again)\n            if (activeStep && activeStep !== el) {\n                onStepLeave(activeStep);\n            }\n            \n            // Now we alter transforms of `root` and `canvas` to trigger transitions.\n            //\n            // And here is why there are two elements: `root` and `canvas` - they are\n            // being animated separately:\n            // `root` is used for scaling and `canvas` for translate and rotations.\n            // Transitions on them are triggered with different delays (to make\n            // visually nice and 'natural' looking transitions), so we need to know\n            // that both of them are finished.\n            css(root, {\n                // to keep the perspective look similar for different scales\n                // we need to 'scale' the perspective, too\n                transform: perspective( config.perspective / targetScale ) + scale( targetScale ),\n                transitionDuration: duration + \"ms\",\n                transitionDelay: (zoomin ? delay : 0) + \"ms\"\n            });\n            \n            css(canvas, {\n                transform: rotate(target.rotate, true) + translate(target.translate),\n                transitionDuration: duration + \"ms\",\n                transitionDelay: (zoomin ? 0 : delay) + \"ms\"\n            });\n            \n            // Here is a tricky part...\n            //\n            // If there is no change in scale or no change in rotation and translation, it means there was actually\n            // no delay - because there was no transition on `root` or `canvas` elements.\n            // We want to trigger `impress:stepenter` event in the correct moment, so here we compare the current\n            // and target values to check if delay should be taken into account.\n            //\n            // I know that this `if` statement looks scary, but it's pretty simple when you know what is going on\n            // - it's simply comparing all the values.\n            if ( currentState.scale === target.scale ||\n                (currentState.rotate.x === target.rotate.x && currentState.rotate.y === target.rotate.y &&\n                 currentState.rotate.z === target.rotate.z && currentState.translate.x === target.translate.x &&\n                 currentState.translate.y === target.translate.y && currentState.translate.z === target.translate.z) ) {\n                delay = 0;\n            }\n            \n            // store current state\n            currentState = target;\n            activeStep = el;\n            \n            // And here is where we trigger `impress:stepenter` event.\n            // We simply set up a timeout to fire it taking transition duration (and possible delay) into account.\n            //\n            // I really wanted to make it in more elegant way. The `transitionend` event seemed to be the best way\n            // to do it, but the fact that I'm using transitions on two separate elements and that the `transitionend`\n            // event is only triggered when there was a transition (change in the values) caused some bugs and \n            // made the code really complicated, cause I had to handle all the conditions separately. And it still\n            // needed a `setTimeout` fallback for the situations when there is no transition at all.\n            // So I decided that I'd rather make the code simpler than use shiny new `transitionend`.\n            //\n            // If you want learn something interesting and see how it was done with `transitionend` go back to\n            // version 0.5.2 of impress.js: http://github.com/bartaz/impress.js/blob/0.5.2/js/impress.js\n            window.clearTimeout(stepEnterTimeout);\n            stepEnterTimeout = window.setTimeout(function() {\n                onStepEnter(activeStep);\n            }, duration + delay);\n            \n            return el;\n        };\n        \n        // `prev` API function goes to previous step (in document order)\n        var prev = function () {\n            var prev = steps.indexOf( activeStep ) - 1;\n            prev = prev >= 0 ? steps[ prev ] : steps[ steps.length-1 ];\n            \n            return goto(prev);\n        };\n        \n        // `next` API function goes to next step (in document order)\n        var next = function () {\n            var next = steps.indexOf( activeStep ) + 1;\n            next = next < steps.length ? steps[ next ] : steps[ 0 ];\n            \n            return goto(next);\n        };\n        \n        // Adding some useful classes to step elements.\n        //\n        // All the steps that have not been shown yet are given `future` class.\n        // When the step is entered the `future` class is removed and the `present`\n        // class is given. When the step is left `present` class is replaced with\n        // `past` class.\n        //\n        // So every step element is always in one of three possible states:\n        // `future`, `present` and `past`.\n        //\n        // There classes can be used in CSS to style different types of steps.\n        // For example the `present` class can be used to trigger some custom\n        // animations when step is shown.\n        root.addEventListener(\"impress:init\", function(){\n            // STEP CLASSES\n            steps.forEach(function (step) {\n                step.classList.add(\"future\");\n            });\n            \n            root.addEventListener(\"impress:stepenter\", function (event) {\n                event.target.classList.remove(\"past\");\n                event.target.classList.remove(\"future\");\n                event.target.classList.add(\"present\");\n            }, false);\n            \n            root.addEventListener(\"impress:stepleave\", function (event) {\n                event.target.classList.remove(\"present\");\n                event.target.classList.add(\"past\");\n            }, false);\n            \n        }, false);\n        \n        // Adding hash change support.\n        root.addEventListener(\"impress:init\", function(){\n            \n            // last hash detected\n            var lastHash = \"\";\n            \n            // `#/step-id` is used instead of `#step-id` to prevent default browser\n            // scrolling to element in hash.\n            //\n            // And it has to be set after animation finishes, because in Chrome it\n            // makes transtion laggy.\n            // BUG: http://code.google.com/p/chromium/issues/detail?id=62820\n            root.addEventListener(\"impress:stepenter\", function (event) {\n                window.location.hash = lastHash = \"#/\" + event.target.id;\n            }, false);\n            \n            window.addEventListener(\"hashchange\", function () {\n                // When the step is entered hash in the location is updated\n                // (just few lines above from here), so the hash change is \n                // triggered and we would call `goto` again on the same element.\n                //\n                // To avoid this we store last entered hash and compare.\n                if (window.location.hash !== lastHash) {\n                    goto( getElementFromHash() );\n                }\n            }, false);\n            \n            // START \n            // by selecting step defined in url or first step of the presentation\n            goto(getElementFromHash() || steps[0], 0);\n        }, false);\n        \n        body.classList.add(\"impress-disabled\");\n        \n        // store and return API for given impress.js root element\n        return (roots[ \"impress-root-\" + rootId ] = {\n            init: init,\n            goto: goto,\n            next: next,\n            prev: prev\n        });\n\n    };\n    \n    // flag that can be used in JS to check if browser have passed the support test\n    impress.supported = impressSupported;\n    \n})(document, window);\n\n// NAVIGATION EVENTS\n\n// As you can see this part is separate from the impress.js core code.\n// It's because these navigation actions only need what impress.js provides with\n// its simple API.\n//\n// In future I think about moving it to make them optional, move to separate files\n// and treat more like a 'plugins'.\n(function ( document, window ) {\n    'use strict';\n    \n    // throttling function calls, by Remy Sharp\n    // http://remysharp.com/2010/07/21/throttling-function-calls/\n    var throttle = function (fn, delay) {\n        var timer = null;\n        return function () {\n            var context = this, args = arguments;\n            clearTimeout(timer);\n            timer = setTimeout(function () {\n                fn.apply(context, args);\n            }, delay);\n        };\n    };\n    \n    // wait for impress.js to be initialized\n    document.addEventListener(\"impress:init\", function (event) {\n        // Getting API from event data.\n        // So you don't event need to know what is the id of the root element\n        // or anything. `impress:init` event data gives you everything you \n        // need to control the presentation that was just initialized.\n        var api = event.detail.api;\n        \n        // KEYBOARD NAVIGATION HANDLERS\n        \n        // Prevent default keydown action when one of supported key is pressed.\n        document.addEventListener(\"keydown\", function ( event ) {\n            if ( event.keyCode === 9 || ( event.keyCode >= 32 && event.keyCode <= 34 ) || (event.keyCode >= 37 && event.keyCode <= 40) ) {\n                event.preventDefault();\n            }\n        }, false);\n        \n        // Trigger impress action (next or prev) on keyup.\n        \n        // Supported keys are:\n        // [space] - quite common in presentation software to move forward\n        // [up] [right] / [down] [left] - again common and natural addition,\n        // [pgdown] / [pgup] - often triggered by remote controllers,\n        // [tab] - this one is quite controversial, but the reason it ended up on\n        //   this list is quite an interesting story... Remember that strange part\n        //   in the impress.js code where window is scrolled to 0,0 on every presentation\n        //   step, because sometimes browser scrolls viewport because of the focused element?\n        //   Well, the [tab] key by default navigates around focusable elements, so clicking\n        //   it very often caused scrolling to focused element and breaking impress.js\n        //   positioning. I didn't want to just prevent this default action, so I used [tab]\n        //   as another way to moving to next step... And yes, I know that for the sake of\n        //   consistency I should add [shift+tab] as opposite action...\n        document.addEventListener(\"keyup\", function ( event ) {\n            if ( event.keyCode === 9 || ( event.keyCode >= 32 && event.keyCode <= 34 ) || (event.keyCode >= 37 && event.keyCode <= 40) ) {\n                switch( event.keyCode ) {\n                    case 33: // pg up\n                    case 37: // left\n                    case 38: // up\n                             api.prev();\n                             break;\n                    case 9:  // tab\n                    case 32: // space\n                    case 34: // pg down\n                    case 39: // right\n                    case 40: // down\n                             api.next();\n                             break;\n                }\n                \n                event.preventDefault();\n            }\n        }, false);\n        \n        // delegated handler for clicking on the links to presentation steps\n        document.addEventListener(\"click\", function ( event ) {\n            // event delegation with \"bubbling\"\n            // check if event target (or any of its parents is a link)\n            var target = event.target;\n            while ( (target.tagName !== \"A\") &&\n                    (target !== document.documentElement) ) {\n                target = target.parentNode;\n            }\n            \n            if ( target.tagName === \"A\" ) {\n                var href = target.getAttribute(\"href\");\n                \n                // if it's a link to presentation step, target this step\n                if ( href && href[0] === '#' ) {\n                    target = document.getElementById( href.slice(1) );\n                }\n            }\n            \n            if ( api.goto(target) ) {\n                event.stopImmediatePropagation();\n                event.preventDefault();\n            }\n        }, false);\n        \n        // delegated handler for clicking on step elements\n        document.addEventListener(\"click\", function ( event ) {\n            var target = event.target;\n            // find closest step element that is not active\n            while ( !(target.classList.contains(\"step\") && !target.classList.contains(\"active\")) &&\n                    (target !== document.documentElement) ) {\n                target = target.parentNode;\n            }\n            \n            if ( api.goto(target) ) {\n                event.preventDefault();\n            }\n        }, false);\n        \n        // touch handler to detect taps on the left and right side of the screen\n        // based on awesome work of @hakimel: https://github.com/hakimel/reveal.js\n        document.addEventListener(\"touchstart\", function ( event ) {\n            if (event.touches.length === 1) {\n                var x = event.touches[0].clientX,\n                    width = window.innerWidth * 0.3,\n                    result = null;\n                    \n                if ( x < width ) {\n                    result = api.prev();\n                } else if ( x > window.innerWidth - width ) {\n                    result = api.next();\n                }\n                \n                if (result) {\n                    event.preventDefault();\n                }\n            }\n        }, false);\n        \n        // rescale presentation when window is resized\n        window.addEventListener(\"resize\", throttle(function () {\n            // force going to active step again, to trigger rescaling\n            api.goto( document.querySelector(\".step.active\"), 500 );\n        }, 250), false);\n        \n    }, false);\n        \n})(document, window);\n\n// THAT'S ALL FOLKS!\n//\n// Thanks for reading it all.\n// Or thanks for scrolling down and reading the last part.\n//\n// I've learnt a lot when building impress.js and I hope this code and comments\n// will help somebody learn at least some part of it.\n"]],"start1":0,"start2":0,"length1":0,"length2":32839}]],"length":32839}
